var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { makeList } from '@or-sdk/base';
import { DataHubSvc, setDiff } from '@or-sdk/data-hub-svc';
import { Tags, filterTagIds, addTagsIds, removeTagIds } from '@or-sdk/tags';
export class Bots {
    constructor(params) {
        const { token, discoveryUrl, accountId, dataHubSvcUrl } = params;
        this.dataHubSvc = new DataHubSvc({
            token,
            discoveryUrl,
            accountId,
            dataHubSvcUrl,
        });
        this.tags = new Tags({
            token,
            discoveryUrl,
            accountId,
            dataHubSvcUrl,
        });
    }
    listBots(params = {}, paginationOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let includeQuery = {};
            if (params.includeDeleted === false || (params.includeDeleted === undefined && params.includeExisting !== false)) {
                includeQuery = { isDeleted: false };
            }
            if (params.includeExisting === false) {
                includeQuery = { isDeleted: true };
            }
            const paramsToSend = Object.assign(Object.assign(Object.assign(Object.assign({}, params), { query: Object.assign(Object.assign({}, params.query), includeQuery) }), paginationOptions), this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {});
            delete paramsToSend.includeDeleted;
            delete paramsToSend.includeExisting;
            const result = yield this.dataHubSvc.makeRequest({
                method: 'GET',
                route: 'bots',
                params: paramsToSend,
            });
            return makeList(result);
        });
    }
    getBot(id, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'GET',
                route: `bots/${id}`,
                params: Object.assign(Object.assign({}, params), this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    saveBot(source) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.dataHubSvc.makeRequest({
                method: 'POST',
                route: `bots/${(source.id && source.id !== 'new') ? source.id : 'new'}`,
                data: {
                    bot: (source.id && source.id !== 'new') ? source : Object.assign(Object.assign({}, source), { id: 'new' }),
                },
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
            return setDiff(source, result);
        });
    }
    deleteBot(botId, temporarily = true) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'DELETE',
                route: `bots/${botId}`,
                data: {
                    temporarily,
                },
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    recoverBot(botId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'PATCH',
                route: `bots/${botId}`,
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    downloadTemplate(botTemplateId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'PUT',
                route: 'bots',
                data: {
                    botId: botTemplateId,
                },
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    addTags(source, tagNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = yield this.tags.getMultipleTagsByName(tagNames, true);
            const tagIds = tags.map(tag => tag.id);
            const { newIds } = filterTagIds(source.tags, tagIds);
            if (!newIds.length) {
                throw Error('No tags to add.');
            }
            return this.saveBot(Object.assign(Object.assign({}, source), { tags: addTagsIds(source.tags, newIds) }));
        });
    }
    removeTags(source, tagNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = yield this.tags.getMultipleTagsByName(tagNames);
            const tagIds = tags.map(tag => tag.id);
            const { existingIds } = filterTagIds(source.tags, tagIds);
            if (!existingIds.length) {
                throw Error('No tags to remove.');
            }
            return this.saveBot(Object.assign(Object.assign({}, source), { tags: removeTagIds(source.tags, existingIds) }));
        });
    }
}
//# sourceMappingURL=Bots.js.map