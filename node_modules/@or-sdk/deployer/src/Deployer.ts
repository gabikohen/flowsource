import { Base, timeout } from '@or-sdk/base';
import {
  DeployerConfig,
  Flow, PollingParams,
  PollingResult,
  PollingResultActivateSuccess,
  PollingResultDeactivateSuccess,
  PollingResultError,
  PollingResultPending,
} from './types';
import { SERVICE_KEY } from './constants';

export class Deployer extends Base {

  constructor(params: DeployerConfig) {
    const { token, discoveryUrl, accountId, deployerUrl } = params;

    super({
      token,
      discoveryUrl,
      serviceKey: SERVICE_KEY,
      accountId,
      serviceUrl: deployerUrl,
    });
  }

  /**
   * Remove role
   * ```typescript
   * const result = await deployer.removeRole();
   * ```
   */
  public async removeRole(): Promise<void> {
    const route = '/role';

    return this.callApi({
      method: 'DELETE',
      route,
      params: {
        accountId: this.currentAccountId,
      },
    });
  }

  /**
   * Activate flow without polling
   * ```typescript
   * const pollingParams = await deployer.activateFlow(flowSource, false);
   * ```
   */
  public async activateFlowNoPoll({ id, data: { deploy: { role } } }: Flow, interactiveDebug = false): Promise<PollingParams> {
    if (!id) {
      throw new Error('Id is required');
    }

    const flowAlias = `v-${Date.now()}`;

    const data = {
      flowId: id,
      flowAlias,
      interactiveDebug: interactiveDebug,
      role,
    };

    const route = `${ this.isCrossAccount ? `/accounts/${this.currentAccountId}` : '' }/flows/deploy`;

    const { requestId } = await this.callApi({
      method: 'POST',
      route,
      data,
    });

    return {
      flowId: id,
      requestId,
    };
  }

  /**
   * Activate flow
   * ```typescript
   * const triggerList = await deployer.activateFlow(flowSource, false);
   * ```
   */
  public async activateFlow(flowSource: Flow, interactiveDebug = false): Promise<PollingResultActivateSuccess> {
    const { flowId, requestId } = await this.activateFlowNoPoll(flowSource, interactiveDebug);

    return this.pollResult<PollingResultActivateSuccess>({
      flowId,
      requestId,
    });
  }

  /**
   * Deactivate flow without polling
   * ```typescript
   * const pollingParams = await deployer.deactivateFlow(flowSource, 'flowAlias', false);
   * ```
   */
  //TODO: possibly remove flowAlias https://gitlab.com/onereach/platform/deployer/-/issues/57
  public async deactivateFlowNoPoll({ id, data: { deploy: { role } } }: Flow, flowAlias: string, deleteLambda = false): Promise<PollingParams> {
    if (!id) {
      throw new Error('Id is required');
    }

    const data = {
      flow: {
        id,
      },
      flowAlias,
      role,
      deleteLambda,
    };

    const route = `${ this.isCrossAccount ? `/accounts/${this.currentAccountId}` : '' }/flows/deploy`;

    const { requestId } = await this.callApi({
      method: 'DELETE',
      route,
      data,
    });

    return {
      flowId: id,
      requestId,
    };
  }

  /**
   * Deactivate flow
   * ```typescript
   * const deactivatedFlowList = await deployer.deactivateFlow(flowSource, 'flowAlias', false);
   * ```
   */
  //TODO: possibly remove flowAlias https://gitlab.com/onereach/platform/deployer/-/issues/57
  public async deactivateFlow(flowSource: Flow, flowAlias: string, deleteLambda = false): Promise<PollingResultDeactivateSuccess> {
    const { flowId, requestId } = await this.deactivateFlowNoPoll(flowSource, flowAlias, deleteLambda);

    return this.pollResult<PollingResultDeactivateSuccess>({
      flowId,
      requestId,
    });
  }

  /**
   * Polls for activation or deactivation result
   * ```typescript
   * const result = await deployer.pollResult(pollingParams);
   * ```
   */
  public async pollResult<T>({ flowId, requestId }: PollingParams): Promise<T> {
    let counter = 0;

    const route = `${ this.isCrossAccount ? `/accounts/${this.currentAccountId}` : '' }/flows/check/${flowId}/${requestId}`;

    do {
      counter++;
      await timeout(1000);

      const result = await this.callApi<PollingResult>({
        method: 'GET',
        route,
      });

      if ((result as PollingResultPending).status !== 'pending') {
        if ((result as PollingResultError).errorData) {
          throw result;
        }

        return result as T;
      }
    } while (counter < 100);

    throw new Error('Polling is too long');
  }

}
