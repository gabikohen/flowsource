var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { makeList } from '@or-sdk/base';
import { DataHubSvc, setDiff } from '@or-sdk/data-hub-svc';
import { findMissingTagNames } from './utils';
export class Tags {
    constructor(params) {
        const { token, discoveryUrl, accountId, dataHubSvcUrl } = params;
        this.dataHubSvc = new DataHubSvc({
            token,
            discoveryUrl,
            accountId,
            dataHubSvcUrl,
        });
    }
    listAllTags(params = {}, paginationOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.dataHubSvc.makeRequest({
                method: 'GET',
                route: 'tags',
                params: Object.assign(Object.assign(Object.assign({}, params), paginationOptions), this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
            return makeList(result);
        });
    }
    listTags(params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.listAllTags(Object.assign(Object.assign({}, params), { query: Object.assign(Object.assign({}, params.query), { isDeleted: false }) }));
        });
    }
    getTagById(id, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'GET',
                route: `tags/${id}`,
                params: Object.assign(Object.assign({}, params), this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    getMultipleTagsByName(tagNames, createMissing = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const { items: tagList } = yield this.listTags();
            let tags = tagList.filter((tag) => tagNames.find(tagName => tagName === tag.data.label));
            if (createMissing) {
                const missingTagNames = findMissingTagNames(tags, tagNames);
                const newTags = [];
                for (const tagName of missingTagNames) {
                    const newTag = yield this.createTag({
                        data: {
                            label: tagName,
                        },
                    });
                    newTags.push(newTag);
                }
                if (newTags.length) {
                    const { items: tagList } = yield this.listTags();
                    tags = tagList.filter((tag) => tagNames.find(tagName => tagName === tag.data.label));
                }
            }
            if (!tags.length) {
                throw Error('No tags were found.');
            }
            return tags;
        });
    }
    getTagByName(tagName, createMissing = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.getMultipleTagsByName([tagName], createMissing);
            return result[0];
        });
    }
    saveTag(source) {
        return __awaiter(this, void 0, void 0, function* () {
            return (source.id && source.id !== 'new') ? this.updateTag(source) : this.createTag(source);
        });
    }
    createTag(source) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.dataHubSvc.makeRequest({
                method: 'POST',
                route: 'tags/new',
                data: {
                    tag: Object.assign(Object.assign({}, source), { id: 'new' }),
                },
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
            return setDiff(source, result);
        });
    }
    updateTag(source) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.dataHubSvc.makeRequest({
                method: 'POST',
                route: `tags/${source.id}`,
                data: {
                    tag: source,
                },
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
            return setDiff(source, result);
        });
    }
    deleteTag(source) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'DELETE',
                route: `tags/${source.id}`,
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
}
//# sourceMappingURL=Tags.js.map