import axios, { AxiosInstance, AxiosRequestHeaders, AxiosRequestConfig, AxiosError } from 'axios';
import { BaseConfig, CalApiParams, MakeApiUrlData, ServiceDiscoveryResponse } from './types';
import { normalizeRoute, normalizeUrl, paramsSerializer, parseAxiosError } from './utils';
import {
  DISCOVERY_ROUTE,
  DISCOVERY_ROUTE_ACCOUNTID,
  DISCOVERY_ROUTE_PROVIDERS_ACCOUNT_ID,
  SdkStatus,
} from './constants';

export abstract class Base {
  private readonly token: string | (() => string);
  private readonly axios: AxiosInstance;
  private readonly discoveryUrl: string | null = null;
  private readonly serviceKey: string;
  private readonly requestAccountId: boolean = false;
  private readonly requestProvidersAccountId: boolean = false;
  private readonly feature: string | null;
  private readonly _isCrossAccount: boolean = false;

  private status: SdkStatus = SdkStatus.NEW;
  private _currentAccountId: string | null = null;
  private _targetAccountId: string | null = null;
  private _providersAccountId: string | null = null;
  private _serviceUrl: string | null = null;


  protected constructor({
    token,
    discoveryUrl,
    serviceKey,
    requestAccountId,
    requestProvidersAccountId,
    feature,
    accountId,
    serviceUrl,
    useDefaultSerializer,
  }: BaseConfig) {
    this.token = token;
    this.discoveryUrl = discoveryUrl || null;
    this.serviceKey = serviceKey;
    this.axios = axios.create(useDefaultSerializer ? {} : { paramsSerializer });
    this._serviceUrl = serviceUrl || null;

    if (accountId) {
      this._currentAccountId = accountId;
      this._targetAccountId = accountId;
      this._isCrossAccount = true;
    } else {
      this.requestAccountId = requestAccountId || false;
    }
    this.requestProvidersAccountId = requestProvidersAccountId || false;
    this.feature = feature || null;
  }

  /**
   * @deprecated used for migration stage only
   * @ignore
   */
  public get currentAccountId(): string | null {
    return this._currentAccountId;
  }

  /** @ignore */
  public get targetAccountId(): string | null {
    return this._targetAccountId;
  }

  /**
   * @deprecated used for migration stage only
   * @ignore
   */
  public get providersAccountId(): string | null {
    return this._providersAccountId;
  }

  /** @ignore */
  public get isCrossAccount(): boolean {
    return this._isCrossAccount;
  }

  /** @ignore */
  async init(): Promise<void> {
    try {
      if (this.serviceUrl) {
        this._serviceUrl = this.makeApiUrl({ url: normalizeUrl(this.serviceUrl) });
      } else if (this.discoveryUrl) {
        const [
          data,
          accountId,
          providersAccountId,
        ]: [
          ServiceDiscoveryResponse,
          ...(string | null)[],
        ] = await Promise.all([
          this.getServiceData(),
          this.requestAccountId ? this.getAccountId() : null,
          this.requestProvidersAccountId ? this.getProvidersAccountId() : null,
        ]);

        if (this.requestAccountId) this._currentAccountId = accountId;
        if (this.requestProvidersAccountId) this._providersAccountId = providersAccountId;

        this._serviceUrl = this.makeApiUrl({
          ...data,
          ... (accountId ? { accountId } : {}),
        });
      } else {
        throw new Error(`Url for '${this.serviceKey}' or 'discoveryUrl' in missing`);
      }
      this.status = SdkStatus.SUCCESS;
    } catch (e) {
      this.status = SdkStatus.ERROR;
      throw e;
    }
  }

  /** @ignore */
  private async getServiceData(): Promise<ServiceDiscoveryResponse> {
    const { data } = await this.axios({
      url: `${normalizeUrl(this.discoveryUrl!)}/${normalizeRoute(DISCOVERY_ROUTE)}`,
      params: {
        serviceName: this.serviceKey,
        ...(this.feature ? { feature: this.feature } : {}),
      },
    });

    return data;
  }

  /** @ignore */
  private async getAccountId(): Promise<string> {
    const { data: { accountId } } = await this.axios({
      url: `${normalizeUrl(this.discoveryUrl!)}/${normalizeRoute(DISCOVERY_ROUTE_ACCOUNTID)}`,
      headers: this.getHeaders(),
    });

    return accountId;
  }

  /** @ignore */
  private async getProvidersAccountId(): Promise<string> {
    const { data: { providersAccountId } } = await this.axios({
      url: `${normalizeUrl(this.discoveryUrl!)}/${normalizeRoute(DISCOVERY_ROUTE_PROVIDERS_ACCOUNT_ID)}`,
      headers: this.getHeaders(),
    });

    return providersAccountId;
  }

  /** @ignore */
  public get serviceUrl(): string | null {
    return this._serviceUrl;
  }

  /**
   *
   * Override this method in case if api url has specific url arguments
   * @ignore
   */
  makeApiUrl(data: MakeApiUrlData): string {
    return data.url;
  }

  /**
   * Method for parsing errors thrown from callApi request
   *
   * Override this method in case if you need specific error handling
   * @ignore
   */
  parseError(e: AxiosError): Error {
    return parseAxiosError(e);
  }

  /** @ignore */
  protected getHeaders(): AxiosRequestHeaders {
    return {
      'Content-Type': 'application/json;charset=UTF-8',
      ... this.getToken() ? { Authorization: this.getToken() } : {},
    };
  }

  /** @ignore */
  private getToken(): string {
    if (typeof this.token === 'string') {
      return this.token;
    }
    if (typeof this.token === 'function') {
      return this.token();
    }
    throw new Error('token is not defined');
  }

  /**
   * Make api request
   * ```typescript
   * const result = await instance.callApi({
   *   route: '/route',
   *   method: 'GET',
   *   data: requestData,
   *   params: queryParams,
   * });
   * ```
   * @ignore
   */
  protected async callApi<T>(params: CalApiParams): Promise<T> {
    if (this.status === SdkStatus.NEW) {
      await this.init();
    }
    try {
      const conf: AxiosRequestConfig = {
        url: `${this._serviceUrl}/${normalizeRoute(params.route)}`,
        method: params.method || 'GET',
        data: params.data,
        params: params.params,
        headers: {
          ...this.getHeaders(),
          ... params.customHeaders ? params.customHeaders : {},
        },
        signal: params.signal,
      };
      const { data } = await this.axios(conf);
      return data;
    } catch (e) {
      throw this.parseError(e as AxiosError);
    }
  }

  /**
   * Make api request
   * ```typescript
   * const result = await instance.callApi({
   *   route: '/route',
   *   method: 'GET',
   *   data: requestData,
   *   params: queryParams,
   * });
   * ```
   * @ignore
   */
  protected async callApiV2<T>(params: CalApiParams): Promise<T> {
    if (this.status === SdkStatus.NEW) {
      await this.init();
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const query: any = params.params || {};
    if (this.isCrossAccount) {
      query.accountId = this.targetAccountId;
    }
    const { data } = await this.axios({
      url: `${params.url || this._serviceUrl}/${normalizeRoute(params.route)}`,
      method: params.method || 'GET',
      data: params.data,
      params: query,
      headers: this.getHeaders(),
      signal: params.signal,
    })
      .catch(e => {
        throw this.parseError(e);
      });

    return data;
  }
}
