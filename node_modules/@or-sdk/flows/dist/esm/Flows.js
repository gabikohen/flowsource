var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { makeList } from '@or-sdk/base';
import { DataHubSvc, setDiff } from '@or-sdk/data-hub-svc';
import { Deployer } from '@or-sdk/deployer';
import { Tags, filterTagIds, addTagsIds, removeTagIds } from '@or-sdk/tags';
import { listUnusedStepTemplates, deleteUnusedStepTemplates } from './utils';
export class Flows {
    constructor(params) {
        const { discoveryUrl, token, accountId, dataHubSvcUrl, deployerUrl } = params;
        this.dataHubSvc = new DataHubSvc({
            token,
            discoveryUrl,
            accountId,
            dataHubSvcUrl,
        });
        this.deployer = new Deployer({
            token,
            discoveryUrl,
            accountId,
            deployerUrl,
        });
        this.tags = new Tags({
            token,
            discoveryUrl,
            accountId,
            dataHubSvcUrl,
        });
    }
    listFlows(botId, params = {}, paginationOptions = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let includeQuery = {};
            if (params.includeDeleted === false || (params.includeDeleted === undefined && params.includeExisting !== false)) {
                includeQuery = { isDeleted: false };
            }
            if (params.includeExisting === false) {
                includeQuery = { isDeleted: true };
            }
            const paramsToSend = Object.assign(Object.assign(Object.assign(Object.assign({}, params), { query: Object.assign(Object.assign({}, params.query), includeQuery) }), paginationOptions), this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {});
            delete paramsToSend.includeDeleted;
            delete paramsToSend.includeExisting;
            const result = yield this.dataHubSvc.makeRequest({
                method: 'GET',
                route: 'flows',
                params: paramsToSend,
            });
            return makeList(result);
        });
    }
    getFlow(id, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'GET',
                route: `flows/${id}`,
                params: Object.assign(Object.assign({}, params), this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    saveFlow(source) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.dataHubSvc.makeRequest({
                method: 'POST',
                route: `flows/${(source.id && source.id !== 'new') ? source.id : 'new'}`,
                data: {
                    flow: (source.id && source.id !== 'new') ? source : Object.assign(Object.assign({}, source), { id: 'new' }),
                    previousVersion: (source.id && source.id !== 'new') ? source.version : undefined,
                },
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
            return setDiff(source, result);
        });
    }
    deleteFlow(flowId, temporarily = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const flowSourceId = typeof flowId === 'string' ? flowId : flowId.id;
            return this.dataHubSvc.makeRequest({
                method: 'DELETE',
                route: `flows/${flowId}`,
                data: {
                    temporarily,
                },
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    recoverFlow(flowId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'PATCH',
                route: `flows/${flowId}`,
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    activateFlow(source, interactiveDebug = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.deployer.activateFlow(source, interactiveDebug);
        });
    }
    deactivateFlow(source, flowAlias, deleteLambda = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.deployer.deactivateFlow(source, flowAlias, deleteLambda);
        });
    }
    listDataOuts(paginationOptions = {}, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.dataHubSvc.makeRequest({
                method: 'GET',
                route: '/flows/data-outs',
                params: Object.assign(Object.assign(Object.assign({}, params), paginationOptions), this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
            return makeList(result);
        });
    }
    addTags(source, tagNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = yield this.tags.getMultipleTagsByName(tagNames, true);
            const tagIds = tags.map(tag => tag.id);
            const { newIds } = filterTagIds(source.tags, tagIds);
            if (!newIds.length) {
                throw Error('No tags to add.');
            }
            return this.saveFlow(Object.assign(Object.assign({}, source), { tags: addTagsIds(source.tags, newIds) }));
        });
    }
    removeTags(source, tagNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const tags = yield this.tags.getMultipleTagsByName(tagNames);
            const tagIds = tags.map(tag => tag.id);
            const { existingIds } = filterTagIds(source.tags, tagIds);
            if (!existingIds.length) {
                throw Error('No tags to remove.');
            }
            return this.saveFlow(Object.assign(Object.assign({}, source), { tags: removeTagIds(source.tags, existingIds) }));
        });
    }
    downloadTemplate(flowTemplateId, botId, shouldUpdateSteps = false) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.dataHubSvc.makeRequest({
                method: 'PUT',
                route: `flows/${botId}`,
                data: {
                    flowId: flowTemplateId,
                    shouldUpdateSteps,
                },
                params: Object.assign({}, this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {}),
            });
        });
    }
    static listUnusedStepTemplates(source) {
        return listUnusedStepTemplates(source);
    }
    static deleteUnusedStepTemplates(source, stepTemplates = []) {
        return deleteUnusedStepTemplates(source, stepTemplates);
    }
}
//# sourceMappingURL=Flows.js.map