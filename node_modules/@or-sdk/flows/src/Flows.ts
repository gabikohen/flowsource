import { List, makeList } from '@or-sdk/base';
import { DataHubSvc, setDiff } from '@or-sdk/data-hub-svc';
import { Deployer, Flow, PollingResultActivateSuccess, PollingResultDeactivateSuccess, StepTemplateRaw } from '@or-sdk/deployer';
import {
  FlowsConfig,
  ListFlowsParams,
  StepTemplateToDelete,
  PaginationOptions,
  DownloadTemplateResult,
  ListDataOutsParams, DataOut, GetFlowParams,
} from './types';
import { Tags, Taggable, filterTagIds, addTagsIds, removeTagIds } from '@or-sdk/tags';
import { listUnusedStepTemplates, deleteUnusedStepTemplates } from './utils';

export class Flows implements Taggable<Flow> {
  private readonly dataHubSvc: DataHubSvc;
  private readonly deployer: Deployer;
  private readonly tags: Tags;

  constructor(params: FlowsConfig) {
    const { discoveryUrl, token, accountId, dataHubSvcUrl, deployerUrl } = params;

    this.dataHubSvc = new DataHubSvc({
      token,
      discoveryUrl,
      accountId,
      dataHubSvcUrl,
    });
    this.deployer = new Deployer({
      token,
      discoveryUrl,
      accountId,
      deployerUrl,
    });
    this.tags = new Tags({
      token,
      discoveryUrl,
      accountId,
      dataHubSvcUrl,
    });
  }

  /**
   * List flows
   * ```typescript
   * const flowsList = await flows.listFlows();
   * ```
   */
  public async listFlows(botId?: string, params: ListFlowsParams = {}, paginationOptions: PaginationOptions = {}): Promise<List<Flow>> {
    let includeQuery = {};

    if (params.includeDeleted === false || (params.includeDeleted === undefined && params.includeExisting !== false)) {
      includeQuery = { isDeleted: false };
    }
    if (params.includeExisting === false) {
      includeQuery = { isDeleted: true };
    }

    const paramsToSend = {
      ...params,
      query: {
        ...params.query,
        ...includeQuery,
      },
      ...paginationOptions,
      ... this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {},
    };

    delete paramsToSend.includeDeleted;
    delete paramsToSend.includeExisting;

    const result = await this.dataHubSvc.makeRequest<Flow[]>({
      method: 'GET',
      route: 'flows',
      params: paramsToSend,
    });

    return makeList<Flow>(result);
  }

  /**
   * Get flow
   * ```typescript
   * const flow = await flows.getFlow('flow-id');
   * ```
   */
  public async getFlow(id: string, params: GetFlowParams = {}): Promise<Flow> {
    return this.dataHubSvc.makeRequest<Flow>({
      method: 'GET',
      route: `flows/${id}`,
      params: {
        ...params,
        ... this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {},
      },
    });
  }

  /**
   * Save flow
   *
   * If source contains existing id - existing flow will be updated
   * ```typescript
   * const savedFlow = await flows.saveFlow(flowSource);
   * ```
   */
  public async saveFlow(source: Flow): Promise<Flow> {
    const result = await this.dataHubSvc.makeRequest<{ id: string; version: string; }>({
      method: 'POST',
      route: `flows/${(source.id && source.id !== 'new') ? source.id : 'new'}`,
      data: {
        flow: (source.id && source.id !== 'new') ? source : {
          ...source,
          id: 'new', //TODO: remove later
        },
        previousVersion: (source.id && source.id !== 'new') ? source.version : undefined,
      },
      params: {
        ... this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {},
      },
    });

    return setDiff<Flow>(source, result);
  }

  /**
   * Delete flow
   * ```typescript
   * await flows.deleteFlow('flow-id');
   * ```
   */
  public async deleteFlow(flowId: string | Flow, temporarily = true): Promise<void> {
    const flowSourceId = typeof flowId === 'string' ? flowId : flowId.id;

    return this.dataHubSvc.makeRequest<void>({
      method: 'DELETE',
      route: `flows/${flowId}`,
      data: {
        temporarily,
      },
      params: {
        ... this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {},
      },
    });
  }

  /**
   * Recover flow
   * ```typescript
   * await flows.recoverFlow('flow-id');
   * ```
   */
  public async recoverFlow(flowId: string): Promise<void> {
    return this.dataHubSvc.makeRequest<void>({
      method: 'PATCH',
      route: `flows/${flowId}`,
      params: {
        ... this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {},
      },
    });
  }

  /**
   * Activate flow
   * ```typescript
   * const triggerList = await flows.activateFlow(flowSource, false);
   * ```
   */
  public async activateFlow(source: Flow, interactiveDebug = false): Promise<PollingResultActivateSuccess> {
    return this.deployer.activateFlow(source, interactiveDebug);
  }

  /**
   * Deactivate flow
   * ```typescript
   * const deactivatedFlowList = await flows.deactivateFlow(flowSource, 'flowAlias', false);
   * ```
   */
  public async deactivateFlow(source: Flow, flowAlias: string, deleteLambda = false): Promise<PollingResultDeactivateSuccess> {
    return this.deployer.deactivateFlow(source, flowAlias, deleteLambda);
  }

  /**
   * List data outs
   * ```typescript
   * const result = await flows.downloadTemplate('flow-template-id', 'bot-id');
   * ```
   */
  public async listDataOuts(paginationOptions: PaginationOptions = {}, params: ListDataOutsParams = {}): Promise<List<DataOut>> {
    const result = await this.dataHubSvc.makeRequest<DataOut[]>({
      method: 'GET',
      route: '/flows/data-outs',
      params: {
        ...params,
        ...paginationOptions,
        ... this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {},
      },
    });

    return makeList<DataOut>(result);
  }

  /**
   * Add tags
   * ```typescript
   * const flow = await flows.addTags(flowSource, tagIdsArr);
   * ```
   */
  public async addTags(source: Flow, tagNames: string[]): Promise<Flow> {
    const tags = await this.tags.getMultipleTagsByName(tagNames, true);
    const tagIds = tags.map(tag => tag.id!);

    const { newIds } = filterTagIds(source.tags, tagIds);

    if (!newIds.length) {
      throw Error('No tags to add.');
    }

    return this.saveFlow({
      ...source,
      tags: addTagsIds(source.tags, newIds),
    });
  }

  /**
   * Remove tags
   * ```typescript
   * const flow = await flows.removeTags(flowSource, tagIdsArr);
   * ```
   */
  public async removeTags(source: Flow, tagNames: string[]): Promise<Flow> {
    const tags = await this.tags.getMultipleTagsByName(tagNames);
    const tagIds = tags.map(tag => tag.id!);

    const { existingIds } = filterTagIds(source.tags, tagIds);

    if (!existingIds.length) {
      throw Error('No tags to remove.');
    }

    return this.saveFlow({
      ...source,
      tags: removeTagIds(source.tags, existingIds),
    });
  }

  /**
   * Download flow template to account
   * ```typescript
   * const result = await flows.downloadTemplate('flow-template-id', 'bot-id');
   * ```
   */
  public async downloadTemplate(flowTemplateId: string, botId: string, shouldUpdateSteps = false): Promise<DownloadTemplateResult> {
    return this.dataHubSvc.makeRequest<DownloadTemplateResult>({
      method: 'PUT',
      route: `flows/${botId}`,
      data: {
        flowId: flowTemplateId,
        shouldUpdateSteps,
      },
      params: {
        ... this.dataHubSvc.isCrossAccount ? { accountId: this.dataHubSvc.currentAccountId } : {},
      },
    });
  }

  /**
   * List unused step templates from flow source
   * ```typescript
   * const result = Flows.getUnusedStepTemplates(source);
   * ```
   */
  public static listUnusedStepTemplates(source: Flow): StepTemplateRaw[] {
    return listUnusedStepTemplates(source);
  }

  /**
   * Delete unused step templates from flow source
   *
   * Can delete specific templates passed as 2nd argument otherwise deletes all unused templates
   * ```typescript
   * const result = Flows.deleteUnusedStepTemplates(source, unusedTemplatesArr);
   * ```
   */
  public static deleteUnusedStepTemplates(source: Flow, stepTemplates: StepTemplateToDelete[] = []): Flow {
    return deleteUnusedStepTemplates(source, stepTemplates);
  }

}
